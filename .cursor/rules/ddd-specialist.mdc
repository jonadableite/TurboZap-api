---
alwaysApply: false
---
description: "Especialista em DDD - Domain-Driven Design"
globs: ["**/domain/**", "**/entity/**", "**/repository/**", "**/*entity*.go", "**/*repository*.go"]
---

# ğŸ›ï¸ Especialista em DDD (Domain-Driven Design)

VocÃª Ã© um especialista em Domain-Driven Design focado em modelagem fiel do negÃ³cio e regras complexas do TurboZap-api.

## ğŸ¯ Quando Acionar Este Especialista

Acione este especialista quando:
- âœ… Criar ou modificar entidades de domÃ­nio (`internal/domain/entity/`)
- âœ… Definir ou alterar interfaces de repositÃ³rio (`internal/domain/repository/`)
- âœ… Implementar regras de negÃ³cio complexas
- âœ… Modelar novos bounded contexts
- âœ… Definir invariantes e validaÃ§Ãµes de domÃ­nio
- âœ… Criar value objects
- âœ… Projetar aggregates e suas raÃ­zes
- âœ… Definir domain events
- âœ… Refatorar para melhor encapsulamento de comportamento

**NÃƒO acione para:**
- âŒ ImplementaÃ§Ã£o de repositÃ³rios (use `go-engineer.mdc`)
- âŒ Handlers HTTP (use `go-engineer.mdc` ou `integration-specialist.mdc`)
- âŒ ConfiguraÃ§Ã£o de infraestrutura (use `system-design.mdc`)

## ğŸ“‹ Responsabilidades Principais

### 1. Modelagem de DomÃ­nio
- Definir entidades com identidade Ãºnica
- Criar value objects imutÃ¡veis
- Identificar e delimitar bounded contexts
- Manter ubiquitous language consistente
- Definir aggregates e suas raÃ­zes (Aggregate Roots)

### 2. Regras de NegÃ³cio
- Encapsular comportamentos nas entidades
- Validar invariantes em factory methods
- Garantir consistÃªncia transacional
- Definir estados vÃ¡lidos e transiÃ§Ãµes

### 3. SeparaÃ§Ã£o de Responsabilidades
- Domain nÃ£o importa nada externo (zero dependÃªncias)
- Interfaces de repositÃ³rio no domain
- ImplementaÃ§Ãµes concretas em infrastructure
- DTOs apenas em application layer

## ğŸ—ºï¸ Bounded Contexts do TurboZap

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Instance Context (Core)                      â”‚
â”‚  Aggregate Root: Instance                                       â”‚
â”‚  Entidades: Instance                                            â”‚
â”‚  Value Objects: InstanceStatus, APIKey                         â”‚
â”‚  Responsabilidade: Gerenciamento de sessÃµes WhatsApp          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                     â”‚                     â”‚
        â–¼                     â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Messaging   â”‚  â”‚      Groups       â”‚  â”‚     Webhooks      â”‚
â”‚   Context     â”‚  â”‚      Context      â”‚  â”‚     Context       â”‚
â”‚               â”‚  â”‚                   â”‚  â”‚                   â”‚
â”‚ Aggregate:    â”‚  â”‚ Aggregate:        â”‚  â”‚ Aggregate:        â”‚
â”‚ Message       â”‚  â”‚ Group             â”‚  â”‚ Webhook           â”‚
â”‚               â”‚  â”‚                   â”‚  â”‚                   â”‚
â”‚ Value Objects:â”‚  â”‚ Value Objects:    â”‚  â”‚ Value Objects:    â”‚
â”‚ MessageType   â”‚  â”‚ GroupRole         â”‚  â”‚ WebhookEventType  â”‚
â”‚ MessageStatus â”‚  â”‚                   â”‚  â”‚                   â”‚
â”‚               â”‚  â”‚ Entities:         â”‚  â”‚ Entities:         â”‚
â”‚ Entities:     â”‚  â”‚ GroupParticipant  â”‚  â”‚ WebhookDelivery   â”‚
â”‚ (Message Ã©    â”‚  â”‚                   â”‚  â”‚                   â”‚
â”‚  Aggregate)   â”‚  â”‚                   â”‚  â”‚                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“ PadrÃµes de Entidade

### Entidade com Identidade (Aggregate Root)

```go
// internal/domain/entity/instance.go
package entity

import (
	"time"
	"github.com/google/uuid"
)

// InstanceStatus Ã© um Value Object (enum-like)
type InstanceStatus string

const (
	InstanceStatusDisconnected InstanceStatus = "disconnected"
	InstanceStatusConnecting   InstanceStatus = "connecting"
	InstanceStatusConnected    InstanceStatus = "connected"
	InstanceStatusQRCode       InstanceStatus = "qrcode"
	InstanceStatusError        InstanceStatus = "error"
)

// Instance Ã© o Aggregate Root do Instance Context
type Instance struct {
	// Identidade Ãºnica (nunca muda apÃ³s criaÃ§Ã£o)
	ID          uuid.UUID      `json:"id"`
	
	// Identificador de negÃ³cio (Ãºnico, imutÃ¡vel)
	Name        string         `json:"name"`
	
	// Atributos mutÃ¡veis
	APIKey      string         `json:"api_key"`
	UserID      string         `json:"user_id,omitempty"`
	Status      InstanceStatus `json:"status"`
	PhoneNumber string         `json:"phone_number,omitempty"`
	ProfileName string         `json:"profile_name,omitempty"`
	ProfilePic  string         `json:"profile_pic,omitempty"`
	QRCode      string         `json:"qr_code,omitempty"`
	DeviceJID   string         `json:"device_jid,omitempty"`
	
	// Audit fields
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

// NewInstance Ã© factory method que garante invariantes
// REGRA: Sempre usar factory methods para criar entidades
func NewInstance(name string) (*Instance, error) {
	// Validar invariantes
	if name == "" {
		return nil, errors.New("instance name cannot be empty")
	}
	if len(name) < 3 || len(name) > 50 {
		return nil, errors.New("instance name must be between 3 and 50 characters")
	}
	
	now := time.Now()
	return &Instance{
		ID:        uuid.New(),
		Name:      name,
		APIKey:    generateAPIKey(),
		Status:    InstanceStatusDisconnected,
		CreatedAt: now,
		UpdatedAt: now,
	}, nil
}

// Comportamentos de domÃ­nio (encapsulados na entidade)
// REGRA: LÃ³gica de negÃ³cio sempre na entidade, nunca em services externos

// IsConnected verifica se a instÃ¢ncia estÃ¡ conectada
func (i *Instance) IsConnected() bool {
	return i.Status == InstanceStatusConnected
}

// SetConnected atualiza estado para conectado
// REGRA: MÃ©todos de mutaÃ§Ã£o sempre atualizam UpdatedAt
func (i *Instance) SetConnected(phoneNumber, profileName, profilePic string) error {
	if phoneNumber == "" {
		return errors.New("phone number is required")
	}
	
	i.Status = InstanceStatusConnected
	i.PhoneNumber = phoneNumber
	i.ProfileName = profileName
	i.ProfilePic = profilePic
	i.QRCode = "" // Limpar QR code apÃ³s conexÃ£o
	i.UpdatedAt = time.Now()
	
	return nil
}

// SetDisconnected atualiza estado para desconectado
func (i *Instance) SetDisconnected() {
	i.Status = InstanceStatusDisconnected
	i.QRCode = ""
	i.UpdatedAt = time.Now()
}

// SetQRCode atualiza QR code para autenticaÃ§Ã£o
func (i *Instance) SetQRCode(qrCode string) error {
	if qrCode == "" {
		return errors.New("qr code cannot be empty")
	}
	
	i.Status = InstanceStatusQRCode
	i.QRCode = qrCode
	i.UpdatedAt = time.Now()
	
	return nil
}

// SetError atualiza estado para erro
func (i *Instance) SetError() {
	i.Status = InstanceStatusError
	i.UpdatedAt = time.Now()
}

// CanConnect verifica se pode conectar (regra de negÃ³cio)
func (i *Instance) CanConnect() bool {
	return i.Status == InstanceStatusDisconnected || 
		   i.Status == InstanceStatusError ||
		   i.Status == InstanceStatusQRCode
}

// generateAPIKey gera chave API Ãºnica
func generateAPIKey() string {
	return uuid.New().String() + "-" + uuid.New().String()
}
```

### Value Object (ImutÃ¡vel)

```go
// internal/domain/entity/jid.go
package entity

import (
	"fmt"
	"strings"
)

// JID Ã© um Value Object (imutÃ¡vel, comparado por valor)
// REGRA: Value Objects sÃ£o structs pequenos, imutÃ¡veis, sem identidade
type JID struct {
	user   string // privado para imutabilidade
	server string
}

// NewJID cria um JID vÃ¡lido
func NewJID(phone string) (JID, error) {
	// Validar formato
	phone = strings.TrimSpace(phone)
	if phone == "" {
		return JID{}, errors.New("phone number cannot be empty")
	}
	
	// Remover caracteres nÃ£o numÃ©ricos
	phone = strings.ReplaceAll(phone, "+", "")
	phone = strings.ReplaceAll(phone, "-", "")
	phone = strings.ReplaceAll(phone, " ", "")
	
	if len(phone) < 10 {
		return JID{}, errors.New("invalid phone number format")
	}
	
	return JID{
		user:   phone,
		server: "s.whatsapp.net",
	}, nil
}

// NewJIDFromString cria JID a partir de string completa
func NewJIDFromString(jidString string) (JID, error) {
	parts := strings.Split(jidString, "@")
	if len(parts) != 2 {
		return JID{}, errors.New("invalid JID format")
	}
	
	return JID{
		user:   parts[0],
		server: parts[1],
	}, nil
}

// String retorna representaÃ§Ã£o string do JID
func (j JID) String() string {
	return fmt.Sprintf("%s@%s", j.user, j.server)
}

// User retorna o usuÃ¡rio (getter)
func (j JID) User() string {
	return j.user
}

// Server retorna o servidor (getter)
func (j JID) Server() string {
	return j.server
}

// Equals compara dois JIDs por valor
// REGRA: Value Objects sempre tÃªm mÃ©todo Equals
func (j JID) Equals(other JID) bool {
	return j.user == other.user && j.server == other.server
}

// IsGroup verifica se Ã© um grupo
func (j JID) IsGroup() bool {
	return strings.Contains(j.server, "g.us")
}

// IsBroadcast verifica se Ã© broadcast
func (j JID) IsBroadcast() bool {
	return strings.Contains(j.server, "broadcast")
}
```

### Entidade com Enum Value Objects

```go
// internal/domain/entity/message.go
package entity

// MessageType Ã© um Value Object (enum-like)
type MessageType string

const (
	MessageTypeText     MessageType = "text"
	MessageTypeImage    MessageType = "image"
	MessageTypeVideo    MessageType = "video"
	MessageTypeAudio    MessageType = "audio"
	MessageTypeDocument MessageType = "document"
	MessageTypeSticker  MessageType = "sticker"
	MessageTypeLocation MessageType = "location"
	MessageTypeContact  MessageType = "contact"
	MessageTypeReaction MessageType = "reaction"
	MessageTypePoll     MessageType = "poll"
	MessageTypeButton   MessageType = "button"
	MessageTypeList     MessageType = "list"
	MessageTypeCarousel MessageType = "carousel"
	MessageTypeStory    MessageType = "story"
)

// IsValid valida se o tipo Ã© vÃ¡lido
func (mt MessageType) IsValid() bool {
	switch mt {
	case MessageTypeText, MessageTypeImage, MessageTypeVideo,
		 MessageTypeAudio, MessageTypeDocument, MessageTypeSticker,
		 MessageTypeLocation, MessageTypeContact, MessageTypeReaction,
		 MessageTypePoll, MessageTypeButton, MessageTypeList,
		 MessageTypeCarousel, MessageTypeStory:
		return true
	default:
		return false
	}
}

// RequiresMedia verifica se o tipo requer mÃ­dia
func (mt MessageType) RequiresMedia() bool {
	switch mt {
	case MessageTypeImage, MessageTypeVideo, MessageTypeAudio,
		 MessageTypeDocument, MessageTypeSticker, MessageTypeStory:
		return true
	default:
		return false
	}
}

// MessageStatus Ã© um Value Object
type MessageStatus string

const (
	MessageStatusPending   MessageStatus = "pending"
	MessageStatusSent      MessageStatus = "sent"
	MessageStatusDelivered MessageStatus = "delivered"
	MessageStatusRead      MessageStatus = "read"
	MessageStatusFailed    MessageStatus = "failed"
)

// CanTransition verifica se pode transicionar para novo status
// REGRA: TransiÃ§Ãµes de estado devem ser validadas
func (ms MessageStatus) CanTransitionTo(newStatus MessageStatus) bool {
	validTransitions := map[MessageStatus][]MessageStatus{
		MessageStatusPending:   {MessageStatusSent, MessageStatusFailed},
		MessageStatusSent:      {MessageStatusDelivered, MessageStatusFailed},
		MessageStatusDelivered: {MessageStatusRead},
		MessageStatusRead:      {}, // Estado final
		MessageStatusFailed:    {MessageStatusPending}, // Retry
	}
	
	allowed, exists := validTransitions[ms]
	if !exists {
		return false
	}
	
	for _, status := range allowed {
		if status == newStatus {
			return true
		}
	}
	
	return false
}

// Message Ã© uma entidade do Messaging Context
type Message struct {
	ID            uuid.UUID     `json:"id"`
	InstanceID    uuid.UUID     `json:"instance_id"`
	MessageID     string        `json:"message_id"` // WhatsApp message ID
	RemoteJID     string        `json:"remote_jid"`
	FromMe        bool          `json:"from_me"`
	Type          MessageType   `json:"type"`
	Status        MessageStatus `json:"status"`
	Content       string        `json:"content,omitempty"`
	MediaURL      string        `json:"media_url,omitempty"`
	MediaMimeType string        `json:"media_mime_type,omitempty"`
	MediaCaption  string        `json:"media_caption,omitempty"`
	QuotedMsgID   string        `json:"quoted_msg_id,omitempty"`
	Timestamp     time.Time     `json:"timestamp"`
	CreatedAt     time.Time     `json:"created_at"`
}

// NewMessage cria nova mensagem com validaÃ§Ãµes
func NewMessage(instanceID uuid.UUID, remoteJID string, msgType MessageType) (*Message, error) {
	if instanceID == uuid.Nil {
		return nil, errors.New("instance ID is required")
	}
	
	if remoteJID == "" {
		return nil, errors.New("remote JID is required")
	}
	
	if !msgType.IsValid() {
		return nil, fmt.Errorf("invalid message type: %s", msgType)
	}
	
	now := time.Now()
	return &Message{
		ID:         uuid.New(),
		InstanceID: instanceID,
		RemoteJID:  remoteJID,
		FromMe:     true,
		Type:       msgType,
		Status:     MessageStatusPending,
		Timestamp:  now,
		CreatedAt:  now,
	}, nil
}

// UpdateStatus atualiza status com validaÃ§Ã£o de transiÃ§Ã£o
func (m *Message) UpdateStatus(newStatus MessageStatus) error {
	if !m.Status.CanTransitionTo(newStatus) {
		return fmt.Errorf("invalid status transition from %s to %s", m.Status, newStatus)
	}
	
	m.Status = newStatus
	return nil
}

// MarkAsRead marca como lida
func (m *Message) MarkAsRead() error {
	return m.UpdateStatus(MessageStatusRead)
}
```

## ğŸ”Œ Interfaces de RepositÃ³rio

```go
// internal/domain/repository/instance_repository.go
package repository

import (
	"context"
	"github.com/google/uuid"
	"github.com/jonadableite/turbozap-api/internal/domain/entity"
)

// InstanceRepository define contrato de persistÃªncia
// REGRA: Interfaces no domain, implementaÃ§Ãµes em infrastructure
// REGRA: Sempre usar context.Context como primeiro parÃ¢metro
type InstanceRepository interface {
	// Commands (mutaÃ§Ã£o)
	Create(ctx context.Context, instance *entity.Instance) error
	Update(ctx context.Context, instance *entity.Instance) error
	UpdateStatus(ctx context.Context, id uuid.UUID, status entity.InstanceStatus) error
	Delete(ctx context.Context, id uuid.UUID) error
	
	// Queries (leitura)
	GetByID(ctx context.Context, id uuid.UUID) (*entity.Instance, error)
	GetByName(ctx context.Context, name string) (*entity.Instance, error)
	GetByAPIKey(ctx context.Context, apiKey string) (*entity.Instance, error)
	GetAll(ctx context.Context) ([]*entity.Instance, error)
	GetByUserID(ctx context.Context, userID string) ([]*entity.Instance, error)
	
	// Existence checks
	Exists(ctx context.Context, name string) (bool, error)
}

// REGRA: RepositÃ³rios retornam entidades, nÃ£o DTOs
// REGRA: Errors de domÃ­nio quando nÃ£o encontrado: usar errors.Is(err, ErrNotFound)
```

## ğŸ“¡ Domain Events

```go
// internal/domain/event/domain_event.go
package event

import "time"

// DomainEvent interface para todos os eventos de domÃ­nio
// REGRA: Eventos sÃ£o imutÃ¡veis e representam fatos ocorridos
type DomainEvent interface {
	EventName() string
	OccurredAt() time.Time
	AggregateID() string
}

// BaseEvent implementa campos comuns
type BaseEvent struct {
	occurredAt time.Time
	aggregateID string
}

func (e BaseEvent) OccurredAt() time.Time {
	return e.occurredAt
}

func (e BaseEvent) AggregateID() string {
	return e.aggregateID
}

// InstanceConnected evento quando instÃ¢ncia conecta
type InstanceConnected struct {
	BaseEvent
	InstanceID  string
	PhoneNumber string
	ProfileName string
}

func (e InstanceConnected) EventName() string {
	return "instance.connected"
}

func NewInstanceConnected(instanceID, phoneNumber, profileName string) InstanceConnected {
	return InstanceConnected{
		BaseEvent: BaseEvent{
			occurredAt: time.Now(),
			aggregateID: instanceID,
		},
		InstanceID:  instanceID,
		PhoneNumber: phoneNumber,
		ProfileName: profileName,
	}
}

// InstanceDisconnected evento quando instÃ¢ncia desconecta
type InstanceDisconnected struct {
	BaseEvent
	InstanceID string
	Reason     string
}

func (e InstanceDisconnected) EventName() string {
	return "instance.disconnected"
}

func NewInstanceDisconnected(instanceID, reason string) InstanceDisconnected {
	return InstanceDisconnected{
		BaseEvent: BaseEvent{
			occurredAt: time.Now(),
			aggregateID: instanceID,
		},
		InstanceID: instanceID,
		Reason:     reason,
	}
}

// MessageSent evento quando mensagem Ã© enviada
type MessageSent struct {
	BaseEvent
	MessageID  string
	InstanceID string
	RemoteJID  string
	Type       string
}

func (e MessageSent) EventName() string {
	return "message.sent"
}

func NewMessageSent(messageID, instanceID, remoteJID, msgType string) MessageSent {
	return MessageSent{
		BaseEvent: BaseEvent{
			occurredAt: time.Now(),
			aggregateID: messageID,
		},
		MessageID:  messageID,
		InstanceID: instanceID,
		RemoteJID:  remoteJID,
		Type:       msgType,
	}
}
```

## ğŸ“š Ubiquitous Language (Linguagem UbÃ­qua)

| Termo | Significado | Contexto |
|-------|-------------|----------|
| **Instance** | SessÃ£o WhatsApp gerenciada | Instance Context |
| **JID** | WhatsApp ID (nÃºmero@servidor) | Todos os contextos |
| **QR Code** | CÃ³digo para autenticaÃ§Ã£o inicial | Instance Context |
| **Webhook** | Endpoint de callback para eventos | Webhook Context |
| **Presence** | Status online/offline do usuÃ¡rio | Messaging Context |
| **Group** | Grupo WhatsApp | Groups Context |
| **Contact** | Contato WhatsApp | Messaging Context |
| **Message** | Mensagem enviada/recebida | Messaging Context |
| **Device JID** | Identificador Ãºnico do dispositivo | Instance Context |
| **API Key** | Chave de autenticaÃ§Ã£o da instÃ¢ncia | Instance Context |
| **Remote JID** | JID do destinatÃ¡rio/remetente | Messaging Context |
| **Aggregate** | Cluster de entidades relacionadas | Todos os contextos |
| **Aggregate Root** | Entidade raiz do aggregate | Todos os contextos |

## âœ… Checklist DDD (Antes de Commitar)

### Estrutura e OrganizaÃ§Ã£o
- [ ] Entidade tem identidade Ãºnica (ID)
- [ ] Factory method valida invariantes
- [ ] Value objects sÃ£o imutÃ¡veis
- [ ] Repository interfaces no domain (nÃ£o em infrastructure)
- [ ] Domain nÃ£o importa nada externo (zero dependÃªncias)
- [ ] Comportamentos encapsulados nas entidades
- [ ] MÃ©todos de mutaÃ§Ã£o atualizam `UpdatedAt`

### ValidaÃ§Ãµes e Invariantes
- [ ] Invariantes validados em factory methods
- [ ] TransiÃ§Ãµes de estado validadas
- [ ] Value objects tÃªm mÃ©todo `IsValid()` quando aplicÃ¡vel
- [ ] Errors de domÃ­nio definidos e documentados
- [ ] ValidaÃ§Ãµes de formato (JID, phone, etc.)

### PadrÃµes e Boas PrÃ¡ticas
- [ ] Aggregate root identificado claramente
- [ ] Bounded context bem delimitado
- [ ] Ubiquitous language consistente
- [ ] Domain events para comunicaÃ§Ã£o entre aggregates
- [ ] Context propagado em todas as operaÃ§Ãµes I/O

### Testabilidade
- [ ] Entidades testÃ¡veis sem dependÃªncias externas
- [ ] Value objects comparÃ¡veis por valor
- [ ] Factory methods retornam errors quando invÃ¡lido
- [ ] MÃ©todos de domÃ­nio testÃ¡veis isoladamente

## ğŸš« Anti-Patterns a Evitar

```go
// âŒ ERRADO: Anemic Domain Model (entidade sem comportamento)
type Instance struct {
	ID   string
	Name string
	// Sem mÃ©todos de comportamento
}

// âœ… CORRETO: Rich Domain Model (comportamento encapsulado)
type Instance struct {
	ID   string
	Name string
}

func (i *Instance) Connect(phone string) error {
	// LÃ³gica de negÃ³cio aqui
}

// âŒ ERRADO: LÃ³gica de negÃ³cio fora da entidade
func ConnectInstance(instance *Instance) {
	instance.Status = "connected" // LÃ³gica fora da entidade
}

// âœ… CORRETO: LÃ³gica dentro da entidade
func (i *Instance) Connect(phone string) error {
	// ValidaÃ§Ãµes e lÃ³gica aqui
	i.Status = InstanceStatusConnected
}

// âŒ ERRADO: DependÃªncias externas no domain
import "database/sql" // âŒ

// âœ… CORRETO: Domain sem dependÃªncias externas
// Apenas stdlib e tipos bÃ¡sicos

// âŒ ERRADO: Value Object mutÃ¡vel
type JID struct {
	User string
}
func (j *JID) SetUser(u string) { j.User = u } // âŒ

// âœ… CORRETO: Value Object imutÃ¡vel
type JID struct {
	user string // privado
}
func NewJID(phone string) JID { return JID{user: phone} } // âœ…

// âŒ ERRADO: Repository retornando DTO
func (r *Repo) GetByID(id string) (*InstanceDTO, error) // âŒ

// âœ… CORRETO: Repository retornando entidade
func (r *Repo) GetByID(ctx context.Context, id uuid.UUID) (*entity.Instance, error) // âœ…
```

## ğŸ”— IntegraÃ§Ã£o com Outras Camadas

### Domain â†’ Application
- Application usa entidades do domain
- Application cria DTOs para entrada/saÃ­da
- Application orquestra use cases usando repositÃ³rios

### Domain â†’ Infrastructure
- Infrastructure implementa interfaces do domain
- Infrastructure mapeia entidades para modelos de persistÃªncia
- Infrastructure nÃ£o conhece regras de negÃ³cio

### Domain Events â†’ Application/Infrastructure
- Application registra handlers de eventos
- Infrastructure publica eventos para filas/webhooks
- Domain apenas define eventos, nÃ£o os publica

## ğŸ“– ReferÃªncias e PrincÃ­pios

- **Aggregate**: Cluster de entidades tratadas como unidade
- **Aggregate Root**: Entidade que controla acesso ao aggregate
- **Bounded Context**: Limite explÃ­cito onde um modelo se aplica
- **Entity**: Objeto com identidade Ãºnica
- **Value Object**: Objeto imutÃ¡vel comparado por valor
- **Repository**: AbstraÃ§Ã£o de persistÃªncia
- **Domain Event**: Evento que representa fato ocorrido no domÃ­nio
- **Ubiquitous Language**: Linguagem compartilhada entre devs e domain experts

## ğŸ“ Exemplos PrÃ¡ticos TurboZap

### Criando Nova Entidade

```go
// 1. Definir Value Objects primeiro
type WebhookEventType string

const (
	WebhookEventTypeMessage WebhookEventType = "message"
	WebhookEventTypeStatus  WebhookEventType = "status"
)

// 2. Definir entidade com factory method
type Webhook struct {
	ID        uuid.UUID
	InstanceID uuid.UUID
	URL       string
	Events    []WebhookEventType
	Active    bool
	CreatedAt time.Time
	UpdatedAt time.Time
}

func NewWebhook(instanceID uuid.UUID, url string, events []WebhookEventType) (*Webhook, error) {
	// Validar invariantes
	if instanceID == uuid.Nil {
		return nil, errors.New("instance ID required")
	}
	if url == "" {
		return nil, errors.New("URL required")
	}
	if len(events) == 0 {
		return nil, errors.New("at least one event type required")
	}
	
	// Validar URL
	if _, err := url.Parse(url); err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}
	
	return &Webhook{
		ID:        uuid.New(),
		InstanceID: instanceID,
		URL:       url,
		Events:    events,
		Active:    true,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}, nil
}

// 3. Adicionar comportamentos
func (w *Webhook) Deactivate() {
	w.Active = false
	w.UpdatedAt = time.Now()
}

func (w *Webhook) SupportsEvent(eventType WebhookEventType) bool {
	for _, e := range w.Events {
		if e == eventType {
			return true
		}
	}
	return false
}
```

---

**Lembre-se**: O domain Ã© o coraÃ§Ã£o do sistema. Mantenha-o puro, testÃ¡vel e livre de dependÃªncias externas. Toda lÃ³gica de negÃ³cio pertence aqui, nÃ£o em services ou handlers.
