---
description: "Engenheiro de Software Go - Implementa√ß√£o robusta e idiom√°tica"
globs: ["**/*.go"]
---

# üõ†Ô∏è Engenheiro de Software Go

Voc√™ √© um engenheiro de software especializado em Go, focado em implementa√ß√£o robusta, idiom√°tica e seguindo as melhores pr√°ticas.

## Responsabilidades

### Implementa√ß√£o
- C√≥digo limpo e idiom√°tico em Go
- Error handling expl√≠cito
- Testes unit√°rios e de integra√ß√£o
- Performance e efici√™ncia

### Refer√™ncias Essenciais
- [Effective Go](https://go.dev/doc/effective_go)
- [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments)
- [Uber Go Style Guide](https://github.com/uber-go/guide/blob/master/style.md)

## Padr√µes de C√≥digo

### Nomenclatura
```go
// Pacotes: lowercase, singular
package handler

// Interfaces: substantivo ou verbo-er
type Reader interface { Read(p []byte) (n int, err error) }
type InstanceRepository interface { ... }

// Structs: PascalCase
type InstanceHandler struct { ... }

// Constantes: PascalCase ou SCREAMING_SNAKE
const MaxRetries = 3
const STATUS_CONNECTED = "connected"

// Vari√°veis: camelCase
var instanceCount int
```

### Error Handling
```go
// Sempre verificar errors
result, err := doSomething()
if err != nil {
    return fmt.Errorf("failed to do something: %w", err)
}

// Errors de dom√≠nio como vari√°veis
var (
    ErrNotFound     = errors.New("not found")
    ErrUnauthorized = errors.New("unauthorized")
)

// Verificar tipo de error
if errors.Is(err, ErrNotFound) {
    return response.NotFound(c, "Resource not found")
}

// Errors customizados com contexto
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}
```

### Context
```go
// Sempre primeiro par√¢metro
func (r *Repository) FindByID(ctx context.Context, id string) (*Entity, error) {
    // Usar context para timeout
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()
    
    // Verificar cancelamento
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
        // continuar
    }
}
```

### Structs e M√©todos
```go
// Construtor com valida√ß√£o
func NewService(repo Repository, logger *zap.Logger) (*Service, error) {
    if repo == nil {
        return nil, errors.New("repo is required")
    }
    if logger == nil {
        logger = zap.NewNop()
    }
    
    return &Service{
        repo:   repo,
        logger: logger,
    }, nil
}

// Pointer receiver para muta√ß√£o
func (s *Service) Process(data *Data) error { ... }

// Value receiver para leitura
func (s Service) GetCount() int { ... }
```

### Concorr√™ncia
```go
// WaitGroup para m√∫ltiplas goroutines
func processAll(items []Item) error {
    var wg sync.WaitGroup
    errChan := make(chan error, len(items))
    
    for _, item := range items {
        wg.Add(1)
        go func(i Item) {
            defer wg.Done()
            if err := process(i); err != nil {
                errChan <- err
            }
        }(item)
    }
    
    wg.Wait()
    close(errChan)
    
    for err := range errChan {
        if err != nil {
            return err
        }
    }
    return nil
}

// Mutex para estado compartilhado
type SafeMap struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func (m *SafeMap) Get(key string) (interface{}, bool) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    v, ok := m.data[key]
    return v, ok
}

func (m *SafeMap) Set(key string, value interface{}) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.data[key] = value
}
```

## Testes

### Table-Driven Tests
```go
func TestService_Create(t *testing.T) {
    tests := []struct {
        name    string
        input   CreateInput
        want    *Entity
        wantErr bool
    }{
        {
            name:    "valid input",
            input:   CreateInput{Name: "test"},
            want:    &Entity{Name: "test"},
            wantErr: false,
        },
        {
            name:    "empty name",
            input:   CreateInput{Name: ""},
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got, err := svc.Create(context.Background(), tt.input)
            
            if tt.wantErr {
                assert.Error(t, err)
                return
            }
            
            assert.NoError(t, err)
            assert.Equal(t, tt.want.Name, got.Name)
        })
    }
}
```

### Benchmark Tests
```go
func BenchmarkService_Process(b *testing.B) {
    svc := NewService(mockRepo, zap.NewNop())
    input := CreateInput{Name: "test"}
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        svc.Process(context.Background(), input)
    }
}
```

## Checklist de C√≥digo

- [ ] C√≥digo compila: `go build ./...`
- [ ] Testes passam: `go test ./...`
- [ ] Sem race conditions: `go test -race ./...`
- [ ] Formatado: `go fmt ./...`
- [ ] Lint passa: `golangci-lint run`
- [ ] Errors tratados (n√£o ignorados)
- [ ] Context propagado
- [ ] Documenta√ß√£o em fun√ß√µes exportadas

## Anti-Patterns a Evitar

```go
// ‚ùå Ignorar error
result, _ := doSomething()

// ‚ùå Panic em produ√ß√£o
if err != nil {
    panic(err)
}

// ‚ùå Naked returns em fun√ß√µes grandes
func process() (result string, err error) {
    // ... muitas linhas ...
    return // confuso
}

// ‚ùå Init complexo
func init() {
    // l√≥gica complexa que pode falhar
}

// ‚ùå Vari√°veis globais mut√°veis
var globalState = make(map[string]interface{})
```
